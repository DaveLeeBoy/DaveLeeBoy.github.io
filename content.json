[{"title":"MySQL常用语句","date":"2017-01-22T05:03:37.000Z","path":"posts/uncategorized/2017-01-22-MySQL常用语句.html","text":"","content":"","tags":[]},{"title":"javascript重点小结","date":"2016-12-22T00:29:30.000Z","path":"posts/programming/重点/2016-12-22-javascript经典问题小结.html","text":"数据类型 6种原始值(不可变.’除非重置当前变量,否则不能改变元素值’); a.Null(只有一个值:null) b.Undefined(一个没有被赋值的变量会有个默认值undefined) c.Number d.Boolean(两个值:true和false); e.String f.Symbol和Object(对象指内存中的可以被标识符引用的一块区域) 数据类型检测 typeof(对变量或值调用 typeof 运算符将返回(字符串)下列值之一) a.undefined - Undefined类型 b.number - Number类型 c.boolean - Boolean类型 d.string - String类型 e.symbol - Symbol类型(ECMAScript6新增) f.function - 函数对象([[Call]]在ECMA-262条款中实现了) g.object - 引用类型 或 Null类型 12345typeof(Function) //function(Function是函数对象)typeof(new Function) //function (new Function也是函数对象 ,同等:var func=function()&#123;&#125;)typeof(Array) //function(Array是函数对象)typeof(new Array) //object (实例化的Array就是objec) 变量赋值时候的返回值 12var name=123; //返回undefinedname =456; //返回456; 结语:定义变量的时候赋值返回:undefined 给已声明变量赋值的时候返回当前赋值 获取元素距离页面的top 、left的值 1234567891011function getRec(ele)&#123; var _t=document.documentElement.clientTop, _l=document.documentElement.clientLeft, rect=ele.getBoundingClientRect(); return&#123; top:rect.top-_t, right:rect.right-_l, bottom:rect.bottom-_t, left:rect.left-_l &#125;&#125; js是编译语言,数组长度是随着程序的变化而变化的 1234var arr = [0, 1]; arr[3] = 3;console.log(arr[2]); // undefinedconsole.log(arr.length); // 4 6.LazyMan 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 function _LazyMan(_name) &#123; var _this = this; _this.tasks = []; _this.tasks.push(function() &#123; console.log('Hi! This is ' + _name + '!'); // 这里的this是window，所以要缓存this _this.next(); &#125;); setTimeout(function() &#123; _this.next(); &#125;, 0);&#125;// push函数里面的this和setTimeout函数里面的this都指向全局作用域，所以要缓存当前this指向 _LazyMan.prototype.next = function() &#123; var _fn = this.tasks.shift(); _fn &amp;&amp; _fn(); &#125; _LazyMan.prototype.sleep = function(_time) &#123; var _this = this; _this.tasks.push(function() &#123; setTimeout(function() &#123; console.log('Wake up after ' + _time); _this.next(); &#125;, _time); &#125;); return _this; &#125; _LazyMan.prototype.sleepFirst = function(_time) &#123; var _this = this; _this.tasks.unshift(function() &#123; setTimeout(function() &#123; console.log('Wake up after ' + _time); _this.next(); &#125;, _time); &#125;); return _this; &#125; _LazyMan.prototype.eat = function(_eat) &#123; var _this = this; _this.tasks.push(function() &#123; console.log('Eat ' + _eat); _this.next(); &#125;); return _this; &#125;// 封装对象var LazyMan = function(_name) &#123; return new _LazyMan(_name);&#125; 冒泡排序 123456789101112131415161718192021222324 // 第一轮是对n-1的位置定位// 第二轮是 每一个位置的数的 确定var arr = [1, 4, 5, 6, 99, 111, 112, 113, 133], temp = 0, flag = false;for (var i = 0; i &lt; arr.length - 1; i++) &#123; document.writeln('come'); for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if (flag) &#123; flag = false; &#125; else &#123; break; &#125;&#125;for (var i = 0; i &lt; arr.length; i++) &#123; document.writeln(arr[i]);&#125;; 二分查找 1234567891011121314151617 var arr = [41, 55, 76, 87, 88, 99, 123, 432, 546, 577, 688, 786];function twoFind(arr, wantVal, leftIndex, rightIndex) &#123; if (leftIndex &gt; rightIndex) &#123; document.writeln('SORRY: 找不到 ' + wantVal + ' ！'); return; &#125; var minIndex = Math.floor((leftIndex + rightIndex) / 2); if (arr[minIndex] &gt; wantVal) &#123; twoFind(arr, wantVal, leftIndex, minIndex - 1); &#125; else if (arr[minIndex] &lt; wantVal) &#123; twoFind(arr, wantVal, minIndex + 1, rightIndex); &#125; else &#123; document.writeln('找到了 ' + wantVal + ' ,下表为' + minIndex); &#125;&#125;twoFind(arr, 9, 0, arr.length - 1); js对象访问属性的两种形式 123456function Person()&#123;&#125;var new1=new Person(); new1.name=\"DaveLee\"; new1.age=\"23\"; window.alert(new1.name); window.alert(new1[\"age\"]); js的delete只能删除对象的属性 123456function Person()&#123;&#125;var me=new Person(); me.name=\"DaveLee\"; console.log(me.name); delete me.name; console.log(me.name); 在js中对象的方法不是通用的，如果生成n个对象，那么就有n个内存堆栈 12345678910 // js 中 一切类 继承自 Object 而Object 有propotype// 下面是解决办法 prototype 获得类的static性质 function God() &#123;&#125; God.prototype.shout = function() &#123; window.alert('小狗叫'); &#125; var dog1 = new God(); var dog2 = new God(); dog1.shout(); dog2.shout(); arguments 12345678function abc()&#123; var sum=0; for(var i=0;i&lt;arguments.length;i++)&#123; sum +=arguments[i]; &#125; return sum;&#125;window.alert(abc(1,2,3)); prototype的方法不能访问私有属性和方法 12345678910111213function Person() &#123; var name = 'fj'; //私有 this.age = 21;&#125;Person.prototype.showName = function() &#123; window.alert(this.name);&#125;Person.prototype.showAge = function() &#123; window.alert(this.age);&#125;var p1 = new Person();p1.showName();p1.showAge();","content":"<ol>\n<li><p>数据类型</p>\n<p>6种原始值(不可变.’除非重置当前变量,否则不能改变元素值’);<br> a.Null(只有一个值:null)<br> b.Undefined(一个没有被赋值的变量会有个默认值undefined)<br> c.Number<br> d.Boolean(两个值:true和false);<br> e.String<br> f.Symbol<br>和Object(对象指内存中的可以被标识符引用的一块区域)</p>\n</li>\n<li><p>数据类型检测</p>\n<p>typeof(对变量或值调用 typeof 运算符将返回(字符串)下列值之一)<br> a.undefined - Undefined类型<br> b.number - Number类型<br> c.boolean - Boolean类型<br> d.string - String类型<br> e.symbol - Symbol类型(ECMAScript6新增)<br> f.function - 函数对象([[Call]]在ECMA-262条款中实现了)<br> g.object - 引用类型 或 Null类型</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">typeof(<span class=\"type\">Function</span>) //function(<span class=\"type\">Function</span>是函数对象)</div><div class=\"line\">typeof(new <span class=\"type\">Function</span>) //function (new <span class=\"type\">Function</span>也是函数对象 ,同等:var func=function()&#123;&#125;)</div><div class=\"line\">typeof(<span class=\"type\">Array</span>) //function(<span class=\"type\">Array</span>是函数对象)</div><div class=\"line\">typeof(new <span class=\"type\">Array</span>) //object (实例化的<span class=\"type\">Array</span>就是objec)</div></pre></td></tr></table></figure>\n<ol>\n<li><p>变量赋值时候的返回值</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">name</span>=<span class=\"number\">123</span>; <span class=\"comment\">//返回undefined</span></div><div class=\"line\"><span class=\"keyword\">name</span> =<span class=\"number\">456</span>; <span class=\"comment\">//返回456;</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>结语:定义变量的时候赋值返回:undefined 给已声明变量赋值的时候返回当前赋值</p>\n</blockquote>\n<ol>\n<li>获取元素距离页面的top 、left的值</li>\n</ol>\n<figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getRec(ele)&#123;</div><div class=\"line\">    var _t=document.documentElement.clientTop,</div><div class=\"line\">        _l=document.documentElement.clientLeft,</div><div class=\"line\">        rect=ele.getBoundingClientRect();</div><div class=\"line\">  <span class=\"keyword\">return</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">top</span>:rect.<span class=\"built_in\">top</span>-_t,</div><div class=\"line\">      <span class=\"built_in\">right</span>:rect.<span class=\"built_in\">right</span>-_l,</div><div class=\"line\">      <span class=\"built_in\">bottom</span>:rect.<span class=\"built_in\">bottom</span>-_t,</div><div class=\"line\">      <span class=\"built_in\">left</span>:rect.<span class=\"built_in\">left</span>-_l</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>js是编译语言,数组长度是随着程序的变化而变化的</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</div><div class=\"line\">    arr[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</div><div class=\"line\">console.log(arr[<span class=\"number\">2</span>]); <span class=\"comment\">// undefined</span></div><div class=\"line\">console.log(arr.length); <span class=\"comment\">// 4</span></div></pre></td></tr></table></figure>\n<p>6.LazyMan</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_LazyMan</span>(<span class=\"params\">_name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">    _this.tasks = [];</div><div class=\"line\">    _this.tasks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi! This is '</span> + _name + <span class=\"string\">'!'</span>);</div><div class=\"line\">        <span class=\"comment\">// 这里的this是window，所以要缓存this</span></div><div class=\"line\">        _this.next();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        _this.next();</div><div class=\"line\">    &#125;, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// push函数里面的this和setTimeout函数里面的this都指向全局作用域，所以要缓存当前this指向</span></div><div class=\"line\">    _LazyMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _fn = <span class=\"keyword\">this</span>.tasks.shift();</div><div class=\"line\">        _fn &amp;&amp; _fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">    _LazyMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_time</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">        _this.tasks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'Wake up after '</span> + _time);</div><div class=\"line\">                _this.next();</div><div class=\"line\">            &#125;, _time);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> _this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _LazyMan.prototype.sleepFirst = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_time</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">        _this.tasks.unshift(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'Wake up after '</span> + _time);</div><div class=\"line\">                _this.next();</div><div class=\"line\">            &#125;, _time);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> _this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _LazyMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_eat</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">        _this.tasks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'Eat '</span> + _eat);</div><div class=\"line\">            _this.next();</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">return</span> _this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 封装对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> LazyMan = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(_name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>冒泡排序</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">// 第一轮是对n-1的位置定位</span></div><div class=\"line\"><span class=\"comment\">// 第二轮是 每一个位置的数的 确定</span></div><div class=\"line\">var arr = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">99</span>, <span class=\"number\">111</span>, <span class=\"number\">112</span>, <span class=\"number\">113</span>, <span class=\"number\">133</span>],</div><div class=\"line\">    temp = <span class=\"number\">0</span>,</div><div class=\"line\">    flag = false;</div><div class=\"line\">for (var i = <span class=\"number\">0</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    document.writeln('come');</div><div class=\"line\">    for (var j = <span class=\"number\">0</span>; j &lt; arr.length - <span class=\"number\">1</span> - i; j++) &#123;</div><div class=\"line\">        if (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">            temp = arr[j];</div><div class=\"line\">            arr[j] = arr[j + <span class=\"number\">1</span>];</div><div class=\"line\">            arr[j + <span class=\"number\">1</span>] = temp;</div><div class=\"line\">            flag = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (flag) &#123;</div><div class=\"line\">        flag = false;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">for (var i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</div><div class=\"line\">    document.writeln(arr[i]);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ol>\n<li>二分查找</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">var</span> arr = [<span class=\"number\">41</span>, <span class=\"number\">55</span>, <span class=\"number\">76</span>, <span class=\"number\">87</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>, <span class=\"number\">123</span>, <span class=\"number\">432</span>, <span class=\"number\">546</span>, <span class=\"number\">577</span>, <span class=\"number\">688</span>, <span class=\"number\">786</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">twoFind</span>(<span class=\"params\">arr, wantVal, leftIndex, rightIndex</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (leftIndex &gt; rightIndex) &#123;</div><div class=\"line\">        <span class=\"built_in\">document</span>.writeln(<span class=\"string\">'SORRY: 找不到 '</span> + wantVal + <span class=\"string\">' ！'</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> minIndex = <span class=\"built_in\">Math</span>.floor((leftIndex + rightIndex) / <span class=\"number\">2</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[minIndex] &gt; wantVal) &#123;</div><div class=\"line\">        twoFind(arr, wantVal, leftIndex, minIndex - <span class=\"number\">1</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[minIndex] &lt; wantVal) &#123;</div><div class=\"line\">        twoFind(arr, wantVal, minIndex + <span class=\"number\">1</span>, rightIndex);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">document</span>.writeln(<span class=\"string\">'找到了 '</span> + wantVal + <span class=\"string\">' ,下表为'</span> + minIndex);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">twoFind(arr, <span class=\"number\">9</span>, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<ol>\n<li>js对象访问属性的两种形式</li>\n</ol>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span></span>()&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">1</span>=<span class=\"keyword\">new</span> <span class=\"type\">Person</span>();</div><div class=\"line\">    <span class=\"keyword\">new</span><span class=\"type\">1</span>.name=<span class=\"string\">\"DaveLee\"</span>;</div><div class=\"line\">    <span class=\"keyword\">new</span><span class=\"type\">1</span>.age=<span class=\"string\">\"23\"</span>;</div><div class=\"line\">  window.alert(<span class=\"keyword\">new</span><span class=\"type\">1</span>.name);</div><div class=\"line\">  window.alert(<span class=\"keyword\">new</span><span class=\"type\">1</span>[<span class=\"string\">\"age\"</span>]);</div></pre></td></tr></table></figure>\n<ol>\n<li>js的delete只能删除对象的属性</li>\n</ol>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person()&#123;&#125;</div><div class=\"line\">var <span class=\"keyword\">me</span>=new Person();</div><div class=\"line\">    <span class=\"keyword\">me</span>.<span class=\"built_in\">name</span>=<span class=\"string\">\"DaveLee\"</span>;</div><div class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">me</span>.<span class=\"built_in\">name</span>);</div><div class=\"line\">      delete <span class=\"keyword\">me</span>.<span class=\"built_in\">name</span>;</div><div class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">me</span>.<span class=\"built_in\">name</span>);</div></pre></td></tr></table></figure>\n<ol>\n<li>在js中对象的方法不是通用的，如果生成n个对象，那么就有n个内存堆栈</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">// js 中 一切类 继承自 Object 而Object 有propotype</span></div><div class=\"line\"><span class=\"comment\">// 下面是解决办法 prototype 获得类的static性质</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">God</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    God.prototype.shout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">window</span>.alert(<span class=\"string\">'小狗叫'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> dog1 = <span class=\"keyword\">new</span> God();</div><div class=\"line\">    <span class=\"keyword\">var</span> dog2 = <span class=\"keyword\">new</span> God();</div><div class=\"line\">    dog1.shout();</div><div class=\"line\">    dog2.shout();</div></pre></td></tr></table></figure>\n<ol>\n<li>arguments</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abc</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</div><div class=\"line\">        sum +=<span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">window</span>.alert(abc(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</div></pre></td></tr></table></figure>\n<ol>\n<li>prototype的方法不能访问私有属性和方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'fj'</span>; <span class=\"comment\">//私有</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">21</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">window</span>.alert(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;</div><div class=\"line\">Person.prototype.showAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">window</span>.alert(<span class=\"keyword\">this</span>.age);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">p1.showName();</div><div class=\"line\">p1.showAge();</div></pre></td></tr></table></figure>\n","tags":[]},{"title":"理解Web路由","date":"2016-11-02T01:35:05.000Z","path":"posts/programming/路由/Route/2016-11-02-理解Web路由.html","text":"在Web开发过程中,经常会遇到路由的概率,那么,到底什么是路由呢? 什么是路由 简单来说,路由就是URL到函数的映射. router和route的区别 route就是一条路由，它将一个URL路径和一个函数进行映射，例如： 12/users -&gt; getAllUsers() /users/count -&gt; getUsersCount() 这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。 而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route“。 服务端路由 对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。 以Express为例1234567app.get('/',(req,res)=&gt;&#123; res.sendFile('index') &#125;)app.get('/users',(req,res)=&gt;&#123; db.queryAllUsers() .then(data =&gt;res.send(data)) &#125;) 这里定义了两条路由: 当访问/的时候，会返回index页面 当访问/users的时候，会从数据库中取出所有用户数据并返回 不仅仅是URL在router匹配route的过程中,不仅会根据URL来匹配,还会根据请求的方法来看是否匹配例如在上面的例子,如果通过POST方法来访问/users,就会找不到正确的路由. 客户端路由 对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案: 基于Hash 基于History API (1)基于Hash在URL中#及其后面的部分为hash,例如: 123const url=require('url');var a=url.parse('http://example.com/a/b/#/foo/bar')console.log(a.hash) //=&gt;#/foo/bar hash仅仅是客户端一个状态,也就是,当向服务器发请求的时候,hash部分并不会发过去. 通过监听window对象的hashChange事件,可以简单实现的路由.例如:1234567891011121314window.onhashchange=function()&#123; var hash =window.location.hash; var path=hash.substring(1); switch(path)&#123; case '/': showHome(); break case '/users': showUsersList(); break default: show404NotFound() &#125;&#125; (2)基于History API 通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考: Using the HTML5 History API 我们可以通过监听window对象的popstate事件,来实现简单的路由12345678910111213 window.onpopstate=function()&#123; var path=window.location.pathname; switch(path)&#123; case '/': showHome(); break case '/users': showUsersList(); break default: show404NotFound() &#125;&#125; (3)两种实现的比较 总的来说,基于Hash的路由,兼容性更好,基于History API的路由,更加直观和正式但是,有一点很大 的区别是,基于Hash的路由不需要对服务器做改动,基于History API的路由需要对服务器做一些改造 假设服务器只有如下两个文件(script.js被index.html所引用) 1234567891011/- |- index.html |- script.js // 基于Hash的路径有 http://example.com/ http://example.com/#/foobar //基于History API的路径有 http://example.com/ http://example.com/foobar 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。 当从 http://example.com/跳转到http://example.com/#/foobar 或者 http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问 http://example.com/#/foobar 的时候，实际上向服务器发起的请求是 http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar 的时候，实际上向服务器发起的请求也是 http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了 动态路由 上面的都是静态的路由,也就是路径是固定的,但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。 严格路由 在很多情况下,会遇到/foobar和/foobar/的情况,它们看起来相似,然而实际上有所区别,具体的行为也是实服务器设置而定.末尾有斜线的路径,类比于文件系统的一个目录,末尾没有斜线的路径,类比于一个文件.因此访问/foobar的时候,可能会重定向到/foobar/,而反过来则不会","content":"<blockquote>\n<p>  在Web开发过程中,经常会遇到路由的概率,那么,到底什么是路由呢?</p>\n</blockquote>\n<ol>\n<li><strong>什么是路由</strong></li>\n</ol>\n<p>简单来说,路由就是URL到函数<br>的映射.</p>\n<ol>\n<li><strong>router和route的区别</strong></li>\n</ol>\n<p>route就是一条路由，它将一个URL路径和一个函数进行映射，例如：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/<span class=\"function\"><span class=\"title\">users</span>                -&gt;</span> getAllUsers()  </div><div class=\"line\">/<span class=\"function\"><span class=\"title\">users</span>/count          -&gt;</span> getUsersCount()</div></pre></td></tr></table></figure>\n<p>这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。</p>\n<p>而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route“。</p>\n<a id=\"more\"></a>\n<ol>\n<li><strong>服务端路由</strong></li>\n</ol>\n<p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。<br>  以Express为例<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.get(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"params\">(req,res)</span>=&gt;</span>&#123;</div><div class=\"line\">  res.sendFile(<span class=\"string\">'index'</span>)</div><div class=\"line\"> &#125;)</div><div class=\"line\">app.get(<span class=\"string\">'/users'</span>,<span class=\"function\"><span class=\"params\">(req,res)</span>=&gt;</span>&#123;</div><div class=\"line\"> db.queryAllUsers()</div><div class=\"line\">   .<span class=\"keyword\">then</span>(data =&gt;res.send(data))</div><div class=\"line\"> &#125;)</div></pre></td></tr></table></figure></p>\n<p>这里定义了两条路由:</p>\n<ul>\n<li>当访问/的时候，会返回index页面</li>\n<li>当访问/users的时候，会从数据库中取出所有用户数据并返回</li>\n</ul>\n<p>不仅仅是URL<br>在router匹配route的过程中,不仅会根据URL来匹配,还会根据请求的方法来看是否匹配<br>例如在上面的例子,如果通过POST方法来访问/users,就会找不到正确的路由.</p>\n<ol>\n<li><strong>客户端路由</strong></li>\n</ol>\n<p>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。<br>这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案:</p>\n<ul>\n<li>基于Hash</li>\n<li><p>基于History API</p>\n<p>(1)基于Hash<br>在URL中#及其后面的部分为hash,例如:</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">url</span>=<span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"><span class=\"built_in\">var</span> a=<span class=\"built_in\">url</span>.parse(<span class=\"string\">'http://example.com/a/b/#/foo/bar'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a.hash)  <span class=\"comment\">//=&gt;#/foo/bar</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>hash仅仅是客户端一个状态,也就是,当向服务器发请求的时候,hash部分并不会发过去.</p>\n<p>通过监听window对象的hashChange事件,可以简单实现的路由.例如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.onhashchange=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hash =<span class=\"built_in\">window</span>.location.hash;</div><div class=\"line\">  <span class=\"keyword\">var</span> path=hash.substring(<span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">switch</span>(path)&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">    showHome();</div><div class=\"line\">   <span class=\"keyword\">break</span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'/users'</span>:</div><div class=\"line\">   showUsersList();</div><div class=\"line\">   <span class=\"keyword\">break</span></div><div class=\"line\">   <span class=\"keyword\">default</span>:</div><div class=\"line\">   show404NotFound()</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>(2)基于History API</p>\n<p>通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考:</p>\n<ul>\n<li>Using the HTML5 History API</li>\n</ul>\n<p>我们可以通过监听window对象的popstate事件,来实现简单的路由<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"built_in\">window</span>.onpopstate=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> path=<span class=\"built_in\">window</span>.location.pathname;</div><div class=\"line\">   <span class=\"keyword\">switch</span>(path)&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\">    showHome();</div><div class=\"line\">   <span class=\"keyword\">break</span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'/users'</span>:</div><div class=\"line\">   showUsersList();</div><div class=\"line\">   <span class=\"keyword\">break</span></div><div class=\"line\">   <span class=\"keyword\">default</span>:</div><div class=\"line\">   show404NotFound()</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>(3)两种实现的比较</p>\n<p> 总的来说,基于Hash的路由,兼容性更好,基于History API的路由,更加直观和正式但是,有一点很大<br> 的区别是,基于Hash的路由不需要对服务器做改动,基于History API的路由需要对服务器做一些改造</p>\n<p> 假设服务器只有如下两个文件(script.js被index.html所引用)<br> <figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/-</div><div class=\"line\">  |- index.html</div><div class=\"line\">  |- script.js</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 基于Hash的路径有</span></div><div class=\"line\"><span class=\"symbol\">   http:</span><span class=\"comment\">//example.com/</span></div><div class=\"line\"><span class=\"symbol\">   http:</span><span class=\"comment\">//example.com/#/foobar</span></div><div class=\"line\">   </div><div class=\"line\">  <span class=\"comment\">//基于History API的路径有</span></div><div class=\"line\"><span class=\"symbol\">  http:</span><span class=\"comment\">//example.com/</span></div><div class=\"line\"><span class=\"symbol\">  http:</span><span class=\"comment\">//example.com/foobar</span></div></pre></td></tr></table></figure></p>\n<p>当直接访问<a href=\"http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。\" target=\"_blank\" rel=\"external\">http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。</a></p>\n<p>当从 <a href=\"http://example.com/跳转到http://example.com/#/foobar\" target=\"_blank\" rel=\"external\">http://example.com/跳转到http://example.com/#/foobar</a> 或者 <a href=\"http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。\" target=\"_blank\" rel=\"external\">http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。</a></p>\n<p>当直接访问 <a href=\"http://example.com/#/foobar\" target=\"_blank\" rel=\"external\">http://example.com/#/foobar</a> 的时候，实际上向服务器发起的请求是 <a href=\"http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。\" target=\"_blank\" rel=\"external\">http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。</a></p>\n<p>当直接访问<a href=\"http://example.com/foobar\" target=\"_blank\" rel=\"external\">http://example.com/foobar</a>  的时候，实际上向服务器发起的请求也是 <a href=\"http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。\" target=\"_blank\" rel=\"external\">http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。</a></p>\n<p>因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了</p>\n<ol>\n<li><p><strong>动态路由</strong></p>\n<p>上面的都是静态的路由,也就是路径是固定的,但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。</p>\n</li>\n<li><p><strong>严格路由</strong></p>\n<p>在很多情况下,会遇到/foobar和/foobar/的情况,它们看起来相似,然而实际上有所区别,具体的行为也是实服务器设置而定.<br>末尾有斜线的路径,类比于文件系统的一个目录,末尾没有斜线的路径,类比于一个文件.因此访问/foobar的时候,可能会重定向到/foobar/,而反过来则不会</p>\n</li>\n</ol>\n","tags":[]},{"title":"Javascript小技巧","date":"2016-10-22T02:56:11.000Z","path":"posts/programming/javascript/2016-10-22-Javascript小技巧.html","text":"根据给定条件在原有数组上,得到所需的新数组 1234567891011 var a = [-1, -1, 1, 2, -2, -2, -3, -3, 3, -3];function f(s, e) &#123; var ret = []; for (var i in s) &#123; // 根据原有的数组长度进行循环 ret.push(e(s[i])); &#125; return ret;&#125; f(a, function(n) &#123; return n &gt; 0 ? n : 0 &#125;); // 传输一个匿名函数作为逻辑判断 比原生type或typeof更详细的类型监测方法 1234functio type(p)&#123; /function.(\\w*)\\(\\)/.test(p.constructor); //通过其构造函数来获取对应的类型。 return RegExp.$1;&#125; 对象或数组的深拷贝,用于解决对象引用是值一改全改的问题 123456789var copyObject = function(obj) &#123; var result = &#123;&#125;; for (var x in obj) &#123; result[x] = typeof obj === \"object\" ? copyObject(obj[x]) : obj[x] //如果拷贝的值仍然是一个对象,那么重复执行当前方法。 &#125; return result;&#125; 通过正则表达式来获取cookie的值 123456 function getCookie(name) &#123; if (name &amp;&amp; RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\").exec(document.cookie)) return RegExp.$2; // (^| ) 不匹配第一个空格。 // ([^;]*) 只匹配除了;号之外的所有字符。 // (;|$) 匹配以;号或$为结尾的字符。&#125; 通过位移运算符来替代’parseInt’ 12~~3.14 =&gt;3;// ~~ 取整。~取当前数值的反码,~~表示再次取反，也就是得到当前自身（说明，JS中的“位”运算会将数值自动转换为整数） 将数值转换为16进制的字符创(常用于表示色彩) 1234 (~~ (Math.random() * (1 &lt;&lt; 24))).toString(16)// ~~ 通过位运算来取整。// &lt;&lt; 左移位。将1的二进制数左移24位。而1&lt;&lt;24 == 2^24(RGB模式下最多可表示的色彩数量)// toString(16) 将数值转换为16进制的字符串输出。 正则匹配清除两侧空格 12345var trim=function(v)&#123; var patrn=/^\\s*(.*?)\\s+$/; return (patrn.test(v))?RegExp.$1:\"null\";&#125; 时间格式化 123456function dateFormat(t)&#123; // t 是以秒为单位的值。 var h = ~~(t/3600), // t除以3600，取整，得到的就是小时。 m = ~~(t%3600/60), // t求余3600，取模，得到的就是去除小时剩下的秒数（分钟 + 秒），再除以60，取整，得到的就是分钟。 s = ~~(t%3600%60); // t求余3600，再求余60，剩下的自然就是“秒数”。 return h+'小时'+m+'分'+s+'秒';&#125;","content":"<ol>\n<li>根据给定条件在原有数组上,得到所需的新数组</li>\n</ol>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"keyword\">var</span> a = [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">-2</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>, <span class=\"number\">-3</span>, <span class=\"number\">3</span>, <span class=\"number\">-3</span>];</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(s, e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ret = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> s) &#123; <span class=\"comment\">// 根据原有的数组长度进行循环</span></div><div class=\"line\">        ret.push(e(s[i]));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\">    f(a, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(n)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> ? n : <span class=\"number\">0</span></div><div class=\"line\">    &#125;); <span class=\"comment\">// 传输一个匿名函数作为逻辑判断</span></div></pre></td></tr></table></figure>\n<ol>\n<li>比原生type或typeof更详细的类型监测方法</li>\n</ol>\n<a id=\"more\"></a>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">functio type(p)&#123;</div><div class=\"line\">  /<span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"params\">(\\w*)</span>\\<span class=\"params\">(\\)</span>/.<span class=\"title\">test</span><span class=\"params\">(p.constructor)</span></span>; <span class=\"comment\">//通过其构造函数来获取对应的类型。</span></div><div class=\"line\">  <span class=\"keyword\">return</span> RegExp.$<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>对象或数组的深拷贝,用于解决对象引用是值一改全改的问题</li>\n</ol>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> copyObject = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(obj)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = &#123;&#125;;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">        result[x] = <span class=\"keyword\">typeof</span> obj === <span class=\"string\">\"object\"</span> ? copyObject(obj[x]) : obj[x]</div><div class=\"line\">        <span class=\"comment\">//如果拷贝的值仍然是一个对象,那么重复执行当前方法。</span></div><div class=\"line\">    &#125;　　</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>通过正则表达式来获取cookie的值</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCookie</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (name &amp;&amp; <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^| )\"</span> + name + <span class=\"string\">\"=([^;]*)(;|$)\"</span>).exec(<span class=\"built_in\">document</span>.cookie)) <span class=\"keyword\">return</span> <span class=\"built_in\">RegExp</span>.$<span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"comment\">// (^| ) 不匹配第一个空格。</span></div><div class=\"line\">    <span class=\"comment\">// ([^;]*) 只匹配除了;号之外的所有字符。</span></div><div class=\"line\">    <span class=\"comment\">// (;|$) 匹配以;号或$为结尾的字符。</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>通过位移运算符来替代’parseInt’</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">~~<span class=\"number\">3.14</span> =&gt;<span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// ~~ 取整。~取当前数值的反码,~~表示再次取反，也就是得到当前自身（说明，JS中的“位”运算会将数值自动转换为整数）</span></div></pre></td></tr></table></figure>\n<ol>\n<li>将数值转换为16进制的字符创(常用于表示色彩)</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> (~~ (Math.random() * (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>)</div><div class=\"line\"><span class=\"comment\">// ~~ 通过位运算来取整。</span></div><div class=\"line\"><span class=\"comment\">// &lt;&lt; 左移位。将1的二进制数左移24位。而1&lt;&lt;24 == 2^24(RGB模式下最多可表示的色彩数量)</span></div><div class=\"line\"><span class=\"comment\">// toString(16) 将数值转换为16进制的字符串输出。</span></div></pre></td></tr></table></figure>\n<ol>\n<li>正则匹配清除两侧空格</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> trim=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> patrn=<span class=\"regexp\">/^\\s*(.*?)\\s+$/</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> (patrn.test(v))?<span class=\"built_in\">RegExp</span>.$<span class=\"number\">1</span>:<span class=\"string\">\"null\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>时间格式化</li>\n</ol>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dateFormat</span><span class=\"params\">(t)</span></span>&#123;        <span class=\"comment\">// t 是以秒为单位的值。</span></div><div class=\"line\">    <span class=\"keyword\">var</span> h = ~~(t/<span class=\"number\">3600</span>),        <span class=\"comment\">// t除以3600，取整，得到的就是小时。</span></div><div class=\"line\">        m = ~~(t%<span class=\"number\">3600</span>/<span class=\"number\">60</span>),    <span class=\"comment\">// t求余3600，取模，得到的就是去除小时剩下的秒数（分钟 + 秒），再除以60，取整，得到的就是分钟。</span></div><div class=\"line\">        s = ~~(t%<span class=\"number\">3600</span>%<span class=\"number\">60</span>);    <span class=\"comment\">// t求余3600，再求余60，剩下的自然就是“秒数”。</span></div><div class=\"line\">     <span class=\"keyword\">return</span> h+<span class=\"string\">'小时'</span>+m+<span class=\"string\">'分'</span>+s+<span class=\"string\">'秒'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","tags":[]},{"title":"javascript原型的理解","date":"2016-07-14T03:13:57.000Z","path":"posts/programming/原型/2016-07-14-javascript原型的理解.html","text":"","content":"","tags":[]}]